# Basic Information

|**Name:**|Sepsis Ransomware|
|:-:|:-:|
|**SHA256:**|**3c7d9ecd35b21a2a8fac7cce4fdb3e11c1950d5a02a0c0b369f4082acf00bf9a**|
|**SHA-1**|**518d5a0a8025147b9e29821bccdaf3b42c0d01db**|
|**MD5**|**1221ac9d607af73c65fd6c62bec3d249**|
|**File Type**|**Win32 EXE**|

# Detection:

According to the analysis report by Virus Total the detection rate of the sample is 57/70.

![Detection](Screenshots/Detection.png)

The malware is neither packed nor obfuscated.



# Analysis

## Strings:
There are couple of strings that gives us some important information about the functioning of the malware.

#### HTML code:
  there is HTML code embedded in the strings section which looks to be the ransom message that is displayed by the malware

  ![Strings1](Screenshots/StringsRansomMessage.png)

#### PublicKey:
  There is also a public key hardcoded inside the string sections, which might be used by the ransomware to perform in its encryption routine.

  ![Strings2](Screenshots/StringsPublicKey.png)

## Imports:
  There are calls to **"RegCreateKey"**, **"RegOpenKey"** and **"RegsetvalueExW"**, which are used for creating, opening and modifying windows registry keys respectively.
  there is a call to **"CryptEncrypt"** which is the API for encrypting data.

  ![Imports1](Screenshots/Imports1.png)

  There are calls to **"CreateFile"**, **"DeleteFile"** and **"MoveFile"**, which are used for file handling operations.

  ![Imports2](Screenshots/Imports2.png)

  There are CyptoAPI calls as well like **"CryptImportPublicKeyInfo"**, **"CryptStringToBinary"** and **"CryptDecodeObjectx"** which are imported from **Crypt32.dll**.

  ![Imports3](Screenshots/Imports3.png)

## GetAccessToken
Malware gets the handle of current process and uses **"OpenProcessToken"** and **"GetTokenInformation"** to check if the process has administrative privilages.

If the return value of **OpenProcessToken** is zero the malware will call the **"CloseHandle"** api.

![AccessToken](Screenshots/GetAccessToken.png)

## Get Windows Directory:
If the process has administrative privilages then the malware calls **"GetWindowsDirectoryW"** function to get the location of windows directory and stores a copy of itself by replacing itself with origional **"svchost.exe"**.

![GetWindowsDirectory](Screenshots/GetWindowsDirectory.png)

If the process does no not have administrative privilages the malware finds the address of temporary folder using **"GetTempPathW"** function and stores a copy of itsed as **"svchost.exe"**

![GetTempPath](Screenshots/GetTempPathW.png)

Generally svchost.exe manages the system services that runs from Dynamically Linked Librares(DLL's)

## Modifying Registery Keys:

The malware first opens the registry key **"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"**, with edit access. As the name suggests, Winlogon is used for automatic login in a Windows System, this feature may be a security risk. If you set a computer for autologon, anyone who can physically obtain access to the computer can gain access to all the computer's contents, including any networks it is connected to. Additionally, when autologon is turned on, the password is stored in the registry in plain text.The specific registry key that stores this value can be remotely read by the Authenticated Users group. This malware creats a key named **"Shell"** and sets its value as the path to svchost.exe

![Reg1](Screenshots/Reg1.png)

The malware creates and opens the registry key **"Software\\Classes\\mscfile\\shell\\open\\command"** and sets its value as the address of svchost.exe

![Reg2](Screenshots/Reg2.png)

## Eventvwe.exe:
The malware runs **Eventwe.exe** using **"ShellExecuteW**.
Event viewer is a component of Microsoft's NT line of operating System that lets the administrators and users view the event logs on a local or remote machine.

![Eventvwe](Screenshots/EventViewer.png)

## Mutex:
checks if the mutex "**HJG><JkFWYIguiohgt89573gujhuy78^*(&(^&^$**" exist, if it exists then ExitProcess is called otherwise the the the mutex with same name is created with all access rights.

![Mutex](Screenshots/Mutex.png)

## Cmd Commands execution:

the malaware executes **"/c vssadmin.exe delete shadows /all /quiet & bcdedit.exe /set {default} recoveryenabled no & bcdedit.exe /set {default} bootstatuspolicy ignoreallfailures"** command in cmd.exe using Shellexecute API.

![CmdCommandExecution](Screenshots/CmdCommandExecution.png)

- **"/c vssadmin.exe delete shadows /all"** command is used to delete all the specicified volumes of shadow copies and **"/quiet"** specifies that the command will not display messages while running. Shadow Copy is used to create backup copies or snapshots of computer files or volumes.

- **"bcdedit.exe /set {default} recoveryenabled no & bcdedit.exe /set {default} bootstatuspolicy ignoreallfailures"**, this command is used to disable the automatic windows recovery and to ignore faliures while booting. So basically this command is used so that the windows does not go to the diagnose mode in case of booting error.

## Forming Key & IV:
Looking at the encryption routine we can see that the malware first forms 2 string buffer one of 32bytes and other of 16 bytes using a function which uses **"rand"** function calls to form string.

![KeyAndIVFunc](Screenshots/KeyAndIVFunc.png)

the code of this function is similar to the below code:

```c
char createString(int *addr, int size)
{
  char constantArray[53] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!";
  char \*finalbuffer, ch = '';
  int seed = 34;
  v4 = rand();
  srand(&seed + v4 % 0xC6aea155);
  finalbuffer = (char \*) malloc(size);
  int counter = 0, temp = 0 ;

  if(size != 0)
  {  
    do
    {
      temp = rand() % 100;
      if(temp <= 0x32)
      {
        if(counter < 0x1D)
        {
          temp = rand() % 0x12;
          ch = constantArray[temp + 52];
        }
        else
        {
          temp = rand() % 0x1A;
          ch = constantArray[temp + 26];
        }
      }
      else
      {
        temp = rand() % 0x1A;
        ch = constantArray[temp];
      }
      \*(finalbuffer + counter) = ch;
      counter = counter + 1;
    }while(counter < size)

  }
  return finalbuffer;
}
```
As we can see in the above code that rather than taking the seed variable value, the address of seed variable is taken as argument for **srand** function.

![EncryptfuncStart](Screenshots/EncryptfuncStart.png)

The 32byte string is used as the key and 16byte string as IV by the ransomware for performing encryption. IV is concatenated with the key using **memcpy**.

**"CryptStringToBinaryA"**, converts the PEM format to DER format, A DER file should not have any BEGIN/END statements. It removes header and footer from the base64.

![CryptEncrypt](Screenshots/CryptEncrypt.png)

 **string.CryptDecodeObjectEx**, is used to convert DER file to **CERT_PUBLIC_KEY_INFO**,
**"CryptAcquireContext"** and **"CryptImportPublicKeyInfo"** are used for acuiring the context and extracting the public key from that context respectively.
CryptEncrypt is used to perform the public key encryption of the 48byte buffer(which has key + iv)

![Base64](Screenshots/Base64.png)

Finally base64 encoded string of the CryptEncrypted string is stored in buffer.


## Create Thread:

A new thread is created, it is a recursive function which is used to find path of the files to be encrypted.

![MakingPath](Screenshots/MakingPath.png)

The thread uses **"PathCombineW"** command to concatinate the path and checks if the next file is a directory or not if it is a directory then the function is called again.

![Mapping](Screenshots/Mapping.png)

If path is of a file then the malware fist checks if the file is valid using **CreateFile** function and if the file exist, then size of that file is calculated, and mapping of that file is done having read and write access.

## Encryption:
Malware uses AES encryption to encrypt the files, Key and IV are passed as the values which were origionally created using the **createString** function explained above.

![AES](Screenshots/AesEncryption.png)

The key that was created had a size of 32bytes but the malware uses only first 16 bytes of the key.

![AESinternals](Screenshots/InsideAES.png)

Number of rounds of that each block goes through is also 10 thus AES 128bit encryption is performed by the ransomware to encrypt files.

## Critical Process

Address of NtSetInformationProcess is obtained using getProcessAddress function with address of ntdll.dll as first argument and NtSetInformationProcess as second argument. Address of ntdll.dll is obtained using LoadLibrary function. ntdll.dll is the is used to export windows's native API.

![CriticalProcess](Screenshots/CriticalProcess.png)

The malware uses **"NtsetInformationProcess"** to make the current process as a critical process.

## Ransom Message

![RansomMessage](Screenshots/RansomMessage.png)

HTML code is stored as a string buffer is embedded in the malware, the code is dumped in a file using fwrite and then executed using **"ShellExecuteW"** api.

![RealRansomMessage](Screenshots/RealRansomMessage.png)

The ransom message informs user that all his files have been encrypted and in order to decrypt the files user has to send the mail at **sepsis@protonmail.com** and an ID is provided to user probably for the authour to identify the malware variant.

# Summary
The ransomware first checks the privilages with which it can execute, and based on the privilages, it either goes copies itself to windows directory or temp directory, once copied it changes multiple registry keys to gain access through the windows autologin feature. The malware then creats
The malware creates 32byte key and 16byte iv using a function which uses random numbers to create the string, both key and iv are concatinated with each other and ecrypted using a key wich is hardcoded in the binary, it then base64 encodes the resultant encoded key and stores it in a buffer.

the malware uses AES-128 CBC mode to encrypt the files in the system using the keys that it created using the stringbuilder functions, it runs recursive function to get the list of files that it will encrypt.

After encryption a html page opens which informs user to pay the ransom in bitcoins in order to decrypt the encrypted files.

# References
- Winlogon: [https://support.microsoft.com/en-in/help/324737/how-to-turn-on-automatic-logon-in-windows](https://support.microsoft.com/en-in/help/324737/how-to-turn-on-automatic-logon-in-windows)

- CryptAPI: [https://stackoverflow.com/questions/1231178/load-an-x509-pem-file-into-windows-cryptoapi](https://stackoverflow.com/questions/1231178/load-an-x509-pem-file-into-windows-cryptoapi)

- WindowsAPI: [https://docs.microsoft.com/en-us/windows/desktop/apiindex/windows-api-list](https://docs.microsoft.com/en-us/windows/desktop/apiindex/windows-api-list)
